Assignment 5: Graph Applications – I
SET A –
a) Write a C program for the implementation of Topological sorting.
 #include<stdio.h>
 #define MAX 200
 int n,adj[MAX][MAX];
 int front = -1,rear = -1,queue[MAX];
 void main() {
 int i,j = 0,k;
 int topsort[MAX],indeg[MAX];
create_graph();
 printf(“The adjacency matrix is:\n”);
 display();
 for (i=1;i<+n;i++) {
 indeg[i]=indegree(i);
 if(indeg[i]==0)
 insert_queue(i);
 }
 while(front<=rear) {
 k=delete_queue();
 topsort[j++]=k;
 for (i=1;i<=n;i++) {
 if(adj[k][i]==1) {
 adj[k][i]=0;
 indeg[i]=indeg[i]-1;
 if(indeg[i]==0)
 insert_queue(i);
 }
 }
 }
 printf("Nodes after topological sorting are:\n");
 for (i=0;i<=n;i++)
 printf("%d",topsort[i]);
 printf("\n");
}
create_graph() {
 int i,max_edges,origin,destin;
 printf("\n Enter number of vertices:");
 scamf("%d",&n);
 max_edges = n * (n - 1);
 for (i = 1;i <= max_edges;i++) {
 printf("\n Enter edge %d (00 to quit):",i);
 scanf("%d%d",&origin,&destin);
 if((origin == 0) && (destin == 0)) {
 printf("Invalid edge!!\n");
 i–;
 } else
 adj[origin][destin] = 1;
 }
return;
}
display() {
 int i,j;
 for (i = 0;i <= n;i++) {
 for (j = 1;jrear) {
 printf(“Queue Underflow”);
 return;
 } else {
 del_item = queue[front];
 front = front + 1;
 return del_item;
 }
 }
 int indegree(int node) {
 int i,in_deg = 0;
 for (i = 1;i <= n;i++)
 if(adj[i][node] == 1)
 in_deg++;
 returnin_deg;
 }



b) Write a C program for the Implementation of Prim’s Minimum spanning tree algorithm.
 #include<stdio.h>
 #include<conio.h>
 int a,b,u,v,n,i,j,ne=1;
 int visited[10]= {
 0
 }
 ,min,mincost=0,cost[10][10];
 void main() {
 clrscr();
 printf("\n Enter the number of nodes:");
 scanf("%d",&n);
 printf("\n Enter the adjacency matrix:\n");
 for (i=1;i<=n;i++)
 for (j=1;j<=n;j++) {
 scanf("%d",&cost[i][j]);
 if(cost[i][j]==0)
 cost[i][j]=999;
 }
 visited[1]=1;
 printf("\n");
 while(ne<n) {
 for (i=1,min=999;i<=n;i++)
 for (j=1;j<=n;j++)
 if(cost[i][j]<min)
 if(visited[i]!=0) {
 min=cost[i][j];
 a=u=i;
 b=v=j;
 }
 if(visited[u]==0 || visited[v]==0) {
 printf("\n Edge %d:(%d %d) cost:%d",ne++,a,b,min);
 mincost+=min;
 visited[b]=1;
 }
 cost[a][b]=cost[b][a]=999;
 }
 printf("\n Minimun cost=%d",mincost);
 getch();
}